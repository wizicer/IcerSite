<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title></title>
 <link href="http://icerdesign.com/atom.xml" rel="self"/>
 <link href="http://icerdesign.com"/>
 <updated>2020-09-01T17:30:21+08:00</updated>
 <id>http://icerdesign.com/</id>
 <author>
   <name></name>
 </author>

 
 <entry>
   <title>Compile Android with AMLogic</title>
   <link href="http://icerdesign.com/p/%E6%97%A5%E5%BF%97/compile-amlogic-android/"/>
   <updated>2019-12-10T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E6%97%A5%E5%BF%97/compile-amlogic-android</id>
   <content type="html">&lt;p&gt;Source code downloaded from &lt;a href=&quot;http://www.bee-link.com/forum.php?mod=viewthread&amp;amp;tid=48307&amp;amp;extra=page%3D1&quot;&gt;http://www.bee-link.com/forum.php?mod=viewthread&amp;amp;tid=48307&amp;amp;extra=page%3D1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Referenced following guide:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://nathanpfry.com/how-to-setup-ubuntu-18-04-lts-bionic-beaver-to-compile-android-roms/&quot;&gt;https://nathanpfry.com/how-to-setup-ubuntu-18-04-lts-bionic-beaver-to-compile-android-roms/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://openlinux.amlogic.com/Docs/Common/How_to_build_compiled_server&quot;&gt;http://openlinux.amlogic.com/Docs/Common/How_to_build_compiled_server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://source.android.com/setup/build/initializing&quot;&gt;https://source.android.com/setup/build/initializing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;operating-system&quot;&gt;Operating System&lt;/h2&gt;

&lt;p&gt;Install fresh &lt;code class=&quot;highlighter-rouge&quot;&gt;Ubuntu 18.04 x64&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;prepare-environment&quot;&gt;Prepare environment&lt;/h2&gt;

&lt;p&gt;You could ignore this step as it just avoid git warnings flood log.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.name xxx
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.email xxx@xxx.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;install-go&quot;&gt;Install go&lt;/h2&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;binutils bison gcc make
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;bash &amp;lt; &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gvm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;go1.13 &lt;span class=&quot;nt&quot;&gt;-B&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gvm use go1.13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;install-dependences&quot;&gt;Install dependences&lt;/h2&gt;

&lt;p&gt;Dependences download address:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://releases.linaro.org/archive/13.11/components/toolchain/binaries/&quot;&gt;https://releases.linaro.org/archive/13.11/components/toolchain/binaries/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://releases.linaro.org/components/toolchain/binaries/6.3-2017.02/arm-linux-gnueabihf/&quot;&gt;https://releases.linaro.org/components/toolchain/binaries/6.3-2017.02/arm-linux-gnueabihf/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get remove openjdk-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; icedtea-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;git ccache lzop bison gperf build-essential zip curl zlib1g-dev g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev libghc-bzlib-dev squashfs-tools pngcrush liblz4-tool optipng libc6-dev-i386 gcc-multilib libssl-dev gnupg flex lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev xsltproc unzip python-pip python-dev libffi-dev libxml2-dev libxslt1-dev libjpeg8-dev openjdk-8-jdk
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;gcc-arm-none-eabi
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;u-boot-tools
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-xf&lt;/span&gt; gcc-linaro-aarch64-none-elf-4.8-2013.11_linux.tar.xz
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo mv &lt;/span&gt;gcc-linaro-aarch64-none-elf-4.8-2013.11_linux /opt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-xf&lt;/span&gt; gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf.tar.xz
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo mv &lt;/span&gt;gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf /opt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;start-compile&quot;&gt;Start compile&lt;/h2&gt;

&lt;p&gt;Extract and build image.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-zxf&lt;/span&gt; GT-King_SDK.tar.gz
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;s922x
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./s922x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Output file location: &lt;code class=&quot;highlighter-rouge&quot;&gt;out/target/product/galilei/&lt;/code&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Docker常用命令大全</title>
   <link href="http://icerdesign.com/p/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/docker-command/"/>
   <updated>2019-02-05T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/docker-command</id>
   <content type="html">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;此列表不断更新中&lt;/strong&gt;，最后更新于2019-2-7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;执行命令&quot;&gt;执行命令&lt;/h2&gt;

&lt;p&gt;有时候你需要在一个容器中执行命令，或者干脆启动一个bash——用这个万能的工具完成任务。&lt;/p&gt;

&lt;p&gt;以下分别以Docker和Docker Compose来描述命令。&lt;/p&gt;

&lt;h3 id=&quot;docker&quot;&gt;Docker&lt;/h3&gt;

&lt;p&gt;首先你需要知道容器的名字，不知道的话，可以运行&lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps&lt;/code&gt;命令列出所有运行的容器，从中获取容器名称。&lt;/p&gt;

&lt;p&gt;这里我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;docker exec&lt;/code&gt;命令来执行命令，并配合
&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt;&lt;ruby&gt;交互&lt;rt&gt;interactive&lt;/rt&gt;&lt;/ruby&gt;
和
&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt;&lt;ruby&gt;终端&lt;rt&gt;terminal&lt;/rt&gt;&lt;/ruby&gt;
选项参数来开启终端并保持交互。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; container_name /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt;选项参数可以合并为&lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt;，同时也可以直接执行多条命令。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; container_name sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;echo a &amp;amp;&amp;amp; echo b&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;dockercompose&quot;&gt;Docker Compose&lt;/h3&gt;

&lt;p&gt;如果使用Docker Compose的话，其内含的不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;命令还是&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;命令，都会自动的分配一个终端，
因此只需要简单的执行以下命令。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;container_name /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样的方法可以用来直接执行命令。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;container_name &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是如果需要执行一系列的命令，则需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;sh&lt;/code&gt;命令将他们连接起来。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;container_name sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'echo a &amp;amp;&amp;amp; echo b'&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;进入windows版docker的命令行&quot;&gt;进入Windows版Docker的命令行&lt;/h2&gt;

&lt;p&gt;在使用Windows版Docker时，其实在Hyper-V上运行了一个订制后的Linux，其使用的是LinuxKit发布版本，
但鉴于这个Linux并非时完整的发行版，因此功能是受限的，其实很少是有需要直接进入的。
不过真要是有这个需求，就用以下命令即可。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--privileged&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host justincormack/nsenter1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bretfisher.com/getting-a-shell-in-the-docker-for-windows-vm/&quot;&gt;https://www.bretfisher.com/getting-a-shell-in-the-docker-for-windows-vm/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/justincormack/nsenter1&quot;&gt;nsenter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;将镜像从一台主机传输到另一台主机&quot;&gt;将镜像从一台主机传输到另一台主机&lt;/h2&gt;

&lt;h3 id=&quot;docker-hub&quot;&gt;Docker Hub&lt;/h3&gt;

&lt;p&gt;这是一个公共的Docker镜像集散地，不过他也提供收费的企业版镜像功能，可以不用公开。&lt;/p&gt;

&lt;p&gt;在执行过&lt;code class=&quot;highlighter-rouge&quot;&gt;docker login&lt;/code&gt;之后，可以使用以下命令推送镜像至Docker Hub&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker publish
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自建镜像集散地&quot;&gt;自建镜像集散地&lt;/h3&gt;

&lt;p&gt;我们首先使用以下命令启动
&lt;ruby&gt;自建镜像集散地&lt;rt&gt;Private Registry&lt;/rt&gt;&lt;/ruby&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 5000:5000 &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; registry registry:2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用以下命令将该镜像标记，链接至自建镜像集散地&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker image tag myimage &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ip-address&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:5000/myfirstimage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在第一台主机上，使用以下命令将该镜像推送上去&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker push &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ip-address&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:5000/myfirstimage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在另外一台主机上，使用以下命令将该镜像拉取下来。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker pull &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ip-address&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:5000/myfirstimage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用过程中可能会有证书问题的提示，请根据以下参考网址进行处理。&lt;/p&gt;

&lt;h4 id=&quot;参考-1&quot;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;https://docs.docker.com/registry/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;通过文件传送&quot;&gt;通过文件传送&lt;/h3&gt;

&lt;p&gt;首先在源主机使用以下命令将镜像存储为tar文件&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker save &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &amp;lt;save image to path&amp;gt; &amp;lt;image name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来把这个tar文件拷贝到目标主机上，这个过程你可能会用到&lt;code class=&quot;highlighter-rouge&quot;&gt;cp&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;scp&lt;/code&gt;命令。
拷贝完成后，在这目标主机上执行以下命令，即可将镜像在该主机上恢复出来。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker load &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &amp;lt;path to image &lt;span class=&quot;nb&quot;&gt;tar &lt;/span&gt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果两台主机可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt;进行连接，或许以下快速方法会更加方便，
顺序的完成打包、压缩、传送并释放装载的全过程。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker save &amp;lt;image&amp;gt; | bzip2 | &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      ssh user@host &lt;span class=&quot;s1&quot;&gt;'bunzip2 | docker load'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你所使用系统中含有&lt;code class=&quot;highlighter-rouge&quot;&gt;pv&lt;/code&gt;命令，也可以将其放在其中，可以监控整个流程。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker save &amp;lt;image&amp;gt; | bzip2 | pv | &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      ssh user@host &lt;span class=&quot;s1&quot;&gt;'bunzip2 | docker load'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;参考-2&quot;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/23935141/how-to-copy-docker-images-from-one-host-to-another-without-via-repository&quot;&gt;https://stackoverflow.com/questions/23935141/how-to-copy-docker-images-from-one-host-to-another-without-via-repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;清理空间&quot;&gt;清理空间&lt;/h2&gt;

&lt;p&gt;Docker用久了后，很容易出现空间占用过多的问题，通过以下不同的方式进行清理&lt;/p&gt;

&lt;h3 id=&quot;删除不再使用的镜像&quot;&gt;删除不再使用的镜像&lt;/h3&gt;

&lt;p&gt;通常情况，如果拉取了很多镜像，尤其是在本地多次编译过镜像时尤为突出，
可以使用以下命令删除这些没有被使用的镜像。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker rmi &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;docker images &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--filter&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;dangling=true&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除已经停止的容器&quot;&gt;删除已经停止的容器&lt;/h3&gt;

&lt;p&gt;已经停止的容器，而没有打算保留其状态，也是可以被删除的。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;docker ps &lt;span class=&quot;nt&quot;&gt;--no-trunc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-aq&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;参考-3&quot;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/ngpestelos/4fc2e31e19f86b9cf10b&quot;&gt;https://gist.github.com/ngpestelos/4fc2e31e19f86b9cf10b&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/17236796/how-to-remove-old-docker-containers&quot;&gt;http://stackoverflow.com/questions/17236796/how-to-remove-old-docker-containers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proxy-on-ubuntu&quot;&gt;Proxy on ubuntu&lt;/h2&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Ubuntu 16.04 LTS&lt;/code&gt;系统，可以使用内置的&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd&lt;/code&gt;，步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;建立目录:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; /etc/systemd/system/docker.service.d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/systemd/system/docker.service.d/http-proxy.conf&lt;/code&gt; 文件，内容如下:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Service]
&lt;span class=&quot;nv&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;HTTP_PROXY=https://web-proxy.corp.xxxxxx.com:8080/&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;HTTPS_PROXY=https://web-proxy.corp.xxxxxx.com:8080/&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;Environment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;NO_PROXY=localhost,127.0.0.1,localaddress,.localdomain.com&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;应用变化:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;重启docker:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;参考-4&quot;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/26550360/docker-ubuntu-behind-proxy&quot;&gt;https://stackoverflow.com/questions/26550360/docker-ubuntu-behind-proxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>矿场与矿池</title>
   <link href="http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/%E7%9F%BF%E5%9C%BA%E4%B8%8E%E7%9F%BF%E6%B1%A0/"/>
   <updated>2018-09-27T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/矿场与矿池</id>
   <content type="html">&lt;h2 id=&quot;基本介绍&quot;&gt;基本介绍&lt;/h2&gt;

&lt;p&gt;之所以要把矿场和矿池这两个概念放在一起来讲。是因为这两个概念是非常容易误用。他们是完全不同的两种概念，但他们却有很强的相关性。&lt;/p&gt;

&lt;h3 id=&quot;矿场&quot;&gt;矿场&lt;/h3&gt;

&lt;p&gt;矿场也可以被称之为挖矿基地。是指在地理上集中大量的矿工。基于区块链网络的算力水平不断上升。单个矿工难以获得区块奖励，因此通过规模化，和商业化运作的模式。将大量的矿机集中到挖矿成本较低的地方，进行挖矿。因此矿场的主要成本。来自于购买矿机的硬件成本及矿机运行的电力成本。&lt;/p&gt;

&lt;h3 id=&quot;矿池&quot;&gt;矿池&lt;/h3&gt;

&lt;p&gt;矿池对于区块链来看，是其中的一个完整节点。他通过网络，联合小算力的矿工，合并成大量的算力。以此整合区块链网络中的零散算力，并在所有提供算力的成员中共享奖励。由于区块链全网的算力提升到一定程度后，单个矿工，难以在区块链网络中获得区块奖励。这使得小矿工无法获得稳定的收入。因此通过加入矿池，集结成网络中较大比例的算力。可以比单独获取区块获得奖励几率更大。另外，对于组建一个矿池来说。除了需要一个区块链的完整节点之外，还需要稳定、快速的带宽。&lt;/p&gt;

&lt;h2 id=&quot;矿机&quot;&gt;矿机 &lt;/h2&gt;

&lt;p&gt;矿场的组成元素就是矿工。而矿工手中拥有大量的矿机。我们这里说一下矿机的发展历史。&lt;/p&gt;

&lt;p&gt;从最初使用cpu挖矿，很快的就进化到使用gpu挖矿。然后，随着很多其他行业人士的加入。通过使用电子行业中，常使用的fpga——一种通用的硬件编程芯片，来进一步提升了算力。到现在，已经最终发展到了使用asic——专用集成电路挖矿。这是一种专门为区块链挖矿设计的芯片。它比以往的所有方式来说，拥有体积更小、功耗更低、可靠性更强、性能更高的优点。因此现在被广泛的使用，而前面三种由于已经完全不是asic挖矿的对手，已经被时代淘汰。&lt;/p&gt;

&lt;p&gt;在前面几代的发展过程中，每一代，算力的提升都非常明显，但进入到ASIC挖矿之后。算力的提升将不再会像以前那么明显了。将会和类似于CPU、gpu一样的发展速度，继续通过制造工艺的提升，而提高性能。&lt;/p&gt;

&lt;p&gt;最近有一种新的挖矿形式，是云挖矿。其实算是对以前挖矿方式的一种商业模式的改进。用户已经不再需要自己拥有矿机。来进行挖矿操作，而是可以向矿机服务商租用矿机。依次在云上挖矿。这项服务的出现，也预示着整个挖矿行业的曾经传说般的暴利已经不复存在了。&lt;/p&gt;

&lt;h2 id=&quot;矿池的分类&quot;&gt;矿池的分类 &lt;/h2&gt;

&lt;p&gt;矿池的分类，主要分为&lt;strong&gt;托管矿池&lt;/strong&gt;和&lt;strong&gt;p2p矿池&lt;/strong&gt;。现在的绝大部分矿池都是托管矿池。&lt;/p&gt;

&lt;p&gt;通常情况下，会有一家公司或者个人经营一个矿池服务器。矿池服务器运行着专业软件以及协调矿池中矿工们工作的矿池采矿协议。矿池同时也连接到一个或更多区块链的完整节点。同样的，与其他完整节点一样，矿池服务器也拥有一个完整的区块链数据副本。&lt;/p&gt;

&lt;p&gt;这样的话，可以使得矿工们只需要做计算操作，而无需验证区块和交易。当然，也因此会从矿工的收入当中收取一定百分比的费用，作为矿池的维护费用。&lt;/p&gt;

&lt;p&gt;对于矿工来说，运行一个完整节点的区块链软件，需要监控、维护和频繁升级。缺乏维护和技术都很有可能会导致宕机，宕机就意味着，矿工无法持续的获得利益。因此对于很多矿工来说，不需要运行一个完整节点就能挖矿，是加入托管矿池的一大好处。&lt;/p&gt;

&lt;p&gt;不过，一方面，使用托管矿池也会存在矿池管理员作恶的可能性。矿池管理员可以挟持矿池中所有或部分矿工的算力进行攻击区块链网络。另一方面，中心化的矿池服务器。也可能导致单点故障。例如遭受了DOS拒绝服务攻击，这时，服务器出问题了，或者速度减慢了，这都会使矿池中的矿工不能继续挖矿，而造成利益损失。&lt;/p&gt;

&lt;h3 id=&quot;矿池的中心化问题&quot;&gt;矿池的中心化问题 &lt;/h3&gt;

&lt;p&gt;为了解决这个由中心化造成的问题。提出和实施了一个新的矿池挖矿方法。P2p矿池。它是一种点对点的矿池，没有中心管理员。它通过矿池服务器，去中心化的实现了一个并行的类似于区块链的系统叫做份额链。这是一个难度较低，但专用于记账的区块链系统，它允许矿池中的矿工在一个去中心化的矿池中合作，以每30秒一个份额区块的速度，在份额链上记录，贡献算力的矿工的份额。当原区块链中的区块成功创建了，矿池将根据份额链中的份额数据，奖励所有取得份额的矿工。简言之，他就是使用另一条区块链系统来记录矿工所贡献的算力，并根据其记录分配奖励，这个过程是去中心化的共识机制来做的。&lt;/p&gt;

&lt;p&gt;不过这种方式，比托管矿池更加的复杂，因为他要求矿工需要有专用的计算机，来运行一个区块链的完整节点。以及p2p的挖矿节点软件。它是一种比单独挖矿更有效的混合方法，他不需要像托管矿池那样，给管理员太多权力。不过由于份额链本身也可能遭受51%的攻击。因此它并不能直接解决比特币本身51%攻击的问题，但是作为多样化挖矿生态系统的一部分，它能够使得区块链的生态更加丰富多样，也更加的强大。&lt;/p&gt;

&lt;h3 id=&quot;矿池的利益分配&quot;&gt;矿池的利益分配&lt;/h3&gt;

&lt;p&gt;矿工加入矿池，那必然涉及报酬的分配问题。因此我们这里说一下托管矿池的几种分配模式。&lt;/p&gt;

&lt;p&gt;这里先说明一下——挖矿手续费，这是矿工在矿池挖矿时，支付给矿池的技术服务费。每一种分配模式，一般都会有一定比例的挖矿手续费。&lt;/p&gt;

&lt;p&gt;第一种分配模式是pps。按算力占比获益。即根据你的算力在矿池中的占比，每天给你固定的收益。在这种模式下。矿工只要保证固定的算力。就会获得固定的收益。&lt;/p&gt;

&lt;p&gt;第二种是pplns。按贡献占比获益。他会根据矿工过去一段时间内。成功挖出的区块比例来分配。在这种模式下。分配利益通常具有滞后性和惯性。比如当你新加入到一个矿池中时。刚开始的一段时间，收益都会比较低，因为别人在这个矿池中已经贡献了很多个区块，而你是新来的，你的贡献还很少，所以每一次分配时，收益都较低。但随着时间的推移。挖出来的区块变多了，就会和实际的算力贡献基本上一致了，同样的，当你离开这个矿池不再挖矿的时候。你贡献的区块还在，因此在这之后的一段时间里面，你还依旧能够获得收益。直到历史贡献结算完成。&lt;/p&gt;

&lt;p&gt;对比pps和pplns来说。我们通常情况下可以认为。pps分配模式就类似于打工。你提供算力，矿池回报给你固定的收益。而pplns。就类似于组队。根据各自的贡献来分配利益。&lt;/p&gt;

&lt;p&gt;不过根据老矿工统计，长期来看pps和pplns的收益，基本上是平衡的。&lt;/p&gt;

&lt;p&gt;以上这两种是被用得最为广泛的分配模式，除此之外也有不同的矿池，会提供一些创新的模式，比如说这里还有pps+和solo模式。&lt;/p&gt;

&lt;p&gt;Pps+是融合了pps和pplns两种。其中块奖励根据pps分配，而交易费是根据pplns进行分配。&lt;/p&gt;

&lt;p&gt;而solo，单独挖矿，则是由矿池主要提供技术支持。矿工自己不需要维护完整节点，因此矿池主要是收手续费。&lt;/p&gt;

&lt;h2 id=&quot;矿池的挑战&quot;&gt;矿池的挑战&lt;/h2&gt;

&lt;p&gt;接下来讲一下矿池遇到的挑战。近年来由于矿池行业的企业逐渐走向集中化，因此小矿池在竞争中劣势明显。很难与大矿池进行竞争。矿池的市场定位是服务业。因此行业的前景主要取决于可挖矿币种的行业走向。从现在区块链的发展来看，采用pow工作量证明共识机制的项目逐渐减少。也使得整个挖矿行业都在逐渐变得低迷。&lt;/p&gt;

&lt;p&gt;而对应的，转型也就必须提上议事日程了。包括如何转型到pos共识机制也是需要投入研究精力的。&lt;/p&gt;

&lt;h2 id=&quot;矿工的挑战&quot;&gt;矿工的挑战 &lt;/h2&gt;

&lt;p&gt;另一方面。矿场中的矿工也就受到了不小的挑战。随着时间推移，区块的奖励越来越小。而全网的算力还在不断的增长，也使得矿工获得收益的比例越来越小。即便保持现有的算力。也会使每天的收益变得越来越少。而许多能够提供廉价电力的方式，已经被现在的矿场占领，或宣告非法。寻找更多廉价电力的方式的难度也在逐步提高。另一方面，区块链泡沫破灭带来的价值缩水，会更加使得矿工的产出无法补贴其电力支出。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;去中心化的区块链造就了这么一个独特的产业。它还会存在多久，会有多大的规模，我们都无法预知。未来面临的挑战恐怕会更多。但他们都在切实的证明着区块链的强大。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/0b109ddc0f22&quot;&gt;&lt;em&gt;https://www.jianshu.com/p/0b109ddc0f22&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/282cff61b7a8&quot;&gt;&lt;em&gt;https://www.jianshu.com/p/282cff61b7a8&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/c6182515703f&quot;&gt;&lt;em&gt;https://www.jianshu.com/p/c6182515703f&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/0c991a562fff&quot;&gt;&lt;em&gt;https://www.jianshu.com/p/0c991a562fff&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/挖矿基地/22739236&quot;&gt;&lt;em&gt;https://baike.baidu.com/item/挖矿基地/22739236&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/矿机/6878024?fr=aladdin&quot;&gt;&lt;em&gt;https://baike.baidu.com/item/矿机/6878024?fr=aladdin&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>冷钱包</title>
   <link href="http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/%E5%86%B7%E9%92%B1%E5%8C%85/"/>
   <updated>2018-09-24T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/冷钱包</id>
   <content type="html">&lt;h2 id=&quot;冷钱包的定义&quot;&gt;冷钱包的定义&lt;/h2&gt;

&lt;p&gt;拥有和使用区块链上的货币的一个重要依据就是私钥。这个是需要用户自己保管好的，通常情况下，私钥将会保存在钱包当中，因此钱包的安全性是非常重要的。钱包的简单分类，可以分为冷钱包和热钱包。区别就在于：是否联网。因为冷钱包是不联网的，因此，可以有效的防止黑客攻击。&lt;/p&gt;

&lt;p&gt;冷钱包并不是区块链才有的东西。在过去的日常生活中，大部分同学都是已经使用过的，比如说像银行的u宝、u盾那样的东西。其实就是冷钱包。&lt;/p&gt;

&lt;h2 id=&quot;冷钱包的两种形式&quot;&gt;冷钱包的两种形式&lt;/h2&gt;

&lt;p&gt;冷钱包最初的一种形式是使用纸质媒介。将私钥打印出来。只有当要使用的时候，才将私钥录入到热钱包当中进行使用。但是因为这个过程中，有将私钥录入到热钱包这一过程，使得这个过程当中可能会受到黑客攻击，导致私钥丢失，进而导致资产的损失。&lt;/p&gt;

&lt;p&gt;因此通常情况下，会使用另外一种形式的冷钱包。这也就是前面说到过的，各大银行普遍采用的一种方式——硬件冷钱包。首先私钥是存储在这个硬件的钱包当中的。每次需要使用的时候。都由这个硬件冷钱包进行签名计算。因此私钥并不会经过热钱包。这样就不会导致私钥泄露的情况。&lt;/p&gt;

&lt;h2 id=&quot;冷钱包的安全性&quot;&gt;冷钱包的安全性 &lt;/h2&gt;

&lt;p&gt;不过需要注意的是，冷钱包也不是绝对安全。即便他从理论上讲是非常安全的。但是也不排除这个冷钱包的实现方式上可能会被做手脚。&lt;/p&gt;

&lt;p&gt;首先我们看一下被做手脚的可能性&lt;/p&gt;

&lt;h3 id=&quot;如果使用智能设备作为冷钱包&quot;&gt;如果使用智能设备作为冷钱包&lt;/h3&gt;

&lt;p&gt;第一，有可能会不小心下载了被修改过的冷钱包程序。&lt;/p&gt;

&lt;p&gt;第二，借用他人充电器，的时候可能会遇到恶意改造过的充电器用来向设备中注入恶意程序。&lt;/p&gt;

&lt;h3 id=&quot;如果使用专用设备作为冷钱包虽然被做手脚的可能性大幅度下降但依旧有可能性&quot;&gt;如果使用专用设备作为冷钱包，虽然被做手脚的可能性大幅度下降，但依旧有可能性&lt;/h3&gt;

&lt;p&gt;第一，由内部人员在出厂前就悄悄埋下后门。&lt;/p&gt;

&lt;p&gt;第二，以更新为由，恶意的内部人员可能会将含有恶意程序的新版本更新到用户设备上。&lt;/p&gt;

&lt;h3 id=&quot;具体的修改方式通常有以下几种&quot;&gt;具体的修改方式通常有以下几种：&lt;/h3&gt;

&lt;p&gt;第一。让钱包签名算法中的随机数生成器有问题。如果随机数生成器，生成的随机数有特定规律，这种情况下，即便你的设备并没有联网，只要使用同样的私钥，进行了两笔签名，那便可以通过数学方法推导出私钥是什么。曾经索尼的ps3就是因为使用了不安全的随机数，导致黑客反推出了私钥，最终宣告ps3被彻底破解。&lt;/p&gt;

&lt;p&gt;第二。在签名过程中，做一些手脚，比如说将钱币发送到的地址，修改为黑客自己的地址后再签名。而且更隐蔽的设计可能会是，这样的恶意修改只针对大额资金时。对于小额资金时并不作修改。会使得用户更加防不胜防。&lt;/p&gt;

&lt;p&gt;第三。使用高频声音信息泄露。鉴于系统已经作为冷钱包，完全禁用了网络。黑客依旧可能会使用高频声音信息来进行获取私钥。因为高频声音对于人类来说，是无法听到的，但是录音设备是可以听到。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;总的来说，使用冷钱包绝对是好事，会使得整个过程更加的安全，但是使用一个安全的冷钱包更加重要。&lt;/p&gt;

&lt;p&gt;如果你确实想要问。如何才能保护好冷钱包不会被黑客动手脚呢，那最好的方法应该是。要么随身携带，要么就将他放进安全的保险箱中。&lt;/p&gt;

&lt;p&gt;或者期待未来成熟的无币区块链技术可以带来快速验证程序是否被修改的能力。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/f8eb5aaf8ae6&quot;&gt;&lt;em&gt;https://www.jianshu.com/p/f8eb5aaf8ae6&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/9e5cf428d874&quot;&gt;&lt;em&gt;https://www.jianshu.com/p/9e5cf428d874&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>分布式应用dApp</title>
   <link href="http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8dApp/"/>
   <updated>2018-09-22T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/分布式应用dApp</id>
   <content type="html">&lt;h2 id=&quot;dapp&quot;&gt;dApp&lt;/h2&gt;

&lt;p&gt;app就是我们平时经常提到的app应用的意思。而前面的那个d字母。是表示分布式的意思。因此dApp可以认为是分布式应用。按其定义来说的话，其实只要是运行在分布式系统上，不会因为单个节点的损坏或停止工作导致程序无法运行的分布式应用都可以被称之为dApp。不过，鉴于分布式应用是在区块链的基础上提出的，因此很多时候大家会默认为分布式应用一定是运行在区块链上的。&lt;/p&gt;

&lt;p&gt;关于分布式应用这个概念，还非常的新。因此对于它的具体定义，还有不少的争论。现在这里使用主流的观点来看待分布式应用。&lt;/p&gt;

&lt;p&gt;深入细节前，我先提一个可能很多人都会误用的概念。分布式应用dApp。在一些场合会被写作ÐApp，即在D这个字母当中加了一个横杠。通常，这除了想表明这个分布式应用是在区块链上的特殊应用之外，它还暗含了这个应用是运行在以太坊这个区块链上的含义。因为这种用法，其定义就来自于以太坊，D加一个横杠的这个字母来自于古英语，其读作/ɛð/。写作字母时，就为eth，正好和以太坊的前三个字母eth完全吻合。因此如果一个分布式应用并非运行在以太坊系统上时。应避免使用带横杠的ÐApp。&lt;/p&gt;

&lt;h2 id=&quot;基本构成&quot;&gt;基本构成 &lt;/h2&gt;

&lt;p&gt;一个典型的分布式应用包含界面展现和智能合约两个部分。&lt;/p&gt;

&lt;p&gt;相比传统的app应用程序来说。将传统的应用中的服务器部分换成了区块链上的智能合约。另外，他与传统的应用程序还有一些其他的区别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一是，数据是分布式存储的。&lt;/strong&gt;可以防止中心化和单点故障。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二是，数据是不可篡改的。&lt;/strong&gt;这样才能确保我们使用的是一种稳定的。确定性的应用。是不会受人操控的。&lt;/p&gt;

&lt;h2 id=&quot;开发&quot;&gt;开发&lt;/h2&gt;

&lt;p&gt;在开发基于区块链的分布式应用时，应该考虑以下两点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一，模块化设计。&lt;/strong&gt;由于区块链的不可篡改性。分布式应用一旦上线。除非开发者预留后门，否则是不可能修改的。而预留后门的应用，在用户知晓的情况也是不敢用的。因此为了保证系统的可扩展性。及当前上线模块的稳定性。应考虑分模块设计。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二，商业模式。&lt;/strong&gt;传统的应用可以由开发商付费。让用户体验。最终让一部分用户付费来支撑整个业务。这主要也是因为，开发商提供体验需要付出的代价并不高。而一个具备持续运营能力的分布式应用。很有可能只能是用户付费的。否则开发商就很容易受到女巫攻击。即黑客节点模仿无上限的虚拟用户体验业务。而用户的付费将会支付给，运行程序的区块链节点，也就是通常意义上的矿工。&lt;/p&gt;

&lt;h2 id=&quot;基础区块链的选择&quot;&gt;基础区块链的选择 &lt;/h2&gt;

&lt;p&gt;作为分布式应用的基础区块链的选择，通常情况下有以下几种。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一、选择知名的基础公链。&lt;/strong&gt;当然需要确保这条公链是能够支持你的分布式应用开发的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二、使用定制化的区块链。&lt;/strong&gt;可以从零开始，也可以在现有的开源系统上进行进一步定制，部署时可以是采用公链，也可以是联盟链的形式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三、使用侧链。&lt;/strong&gt;将应用的高频交易数据都保存在侧链中，交易结束后同时回到公链。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Eth&quot;&gt;&lt;em&gt;https://en.wikipedia.org/wiki/Eth&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/0f4a1c5a1389&quot;&gt;&lt;em&gt;https://www.jianshu.com/p/0f4a1c5a1389&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/6a41485170bf&quot;&gt;&lt;em&gt;https://www.jianshu.com/p/6a41485170bf&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>区块链安全</title>
   <link href="http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/"/>
   <updated>2018-09-20T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/区块链安全</id>
   <content type="html">&lt;h2 id=&quot;安全&quot;&gt;安全&lt;/h2&gt;

&lt;p&gt;布道安全这个问题真的是挺难的。大家都会说，安全很重要这件事情是知道的，但要他们花钱花精力去打造安全的系统时，却舍不得了。而且在安全事件发生之前，你不会知道他是否是真的安全，作为新兴的区块链技术，同样有着非常多的安全问题。&lt;/p&gt;

&lt;p&gt;在现在这个区块链时代，如果我们把资产配置在区块链上，会有一种安全感。&lt;/p&gt;

&lt;p&gt;这是一种资产不被会剥夺，价值是基于共识，发行主体无法操控的安全感。&lt;/p&gt;

&lt;p&gt;正是这种安全感，让我们觉得我们自己第一次真正的拥有这种资产，而不是由另外一个第三方进行背书的，永远不会丢失，不会因为发行方，或者政府的干预，政策的变化，而丢失的资产。&lt;/p&gt;

&lt;p&gt;但这种安全感被媒体传达出来后，让用户产生一种错觉，认为自己拥有这个资产就是安全的。&lt;/p&gt;

&lt;p&gt;但事实上，区块链向大众传递的信息应该是：他给予资产所有者，一种权利与自由，想要掌握自己的资产，就得自行承担保管私钥的责任。痛点也就在这，大部分用户并不一定有意愿或者能力去承担这种责任。会觉得，与其自己保存资产，还不如放在有品牌保证的大交易所里面来的安心。这就使得安全问题变得尤为突出。&lt;/p&gt;

&lt;h2 id=&quot;发展&quot;&gt;发展&lt;/h2&gt;

&lt;p&gt;近几年区块链不断的快速发展。从所谓的1.0发展到了3.0，功能是越来越丰富，性能也越来越好，人机交互也变得更加的人性化，但安全性其实一直在退步。&lt;/p&gt;

&lt;p&gt;被称之为区块链1.0的比特币。从上线运行到现在，即便有诸多不满，但不得不说，现在为止，只有他没有严重的安全问题。&lt;/p&gt;

&lt;p&gt;而所谓的区块链2.0——以太坊项目。因为给区块链引入了图灵完备的智能合约功能，使得平台更加灵活、功能更加强大。但也因此带来了大量的安全问题。&lt;/p&gt;

&lt;p&gt;而现在，在许多人口中的所谓的区块链3.0项目——eos项目。为了提高性能，直接使用pos机制。这就已经不是以太坊的智能合约的代码过于灵活带来的安全问题了，而是从架构上就已经放弃了安全。这是从广义上讲，他都已经不是真正的公共区块链了。在以往的公共区块链系统中，区块链节点成网状结构。哪怕有多个节点被黑客攻击，网络依然能够正常运行，但使用pos机制的eos系统，仅有20来个结点，而且这些节点后面，可能只有为数不多的几个人控制着。如果这几个人被控制或者串谋，这个区块链网络的安全性将不复存在。&lt;/p&gt;

&lt;h2 id=&quot;安全的基础&quot;&gt;安全的基础&lt;/h2&gt;

&lt;p&gt;没有免费的安全。比特币为了保证整个系统的安全，使用了pow工作量证明机制，这耗费了大量的电力，但它带来了，信息的公开透明，不可篡改，不可删除，这样的共识结果。&lt;/p&gt;

&lt;p&gt;对于民众来说，区块链的资产也不是绝对安全的。有以下的潜在安全风险：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一，资产不受第三方保护。&lt;/strong&gt;区块链资产在大多数国家都是不受法律保护，公安机关和银行也都没有备案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二，一旦丢失永久丢失。&lt;/strong&gt;由于区块链的匿名信，使得资产一旦丢失，将很难追踪，你不知是谁偷的，也无法证明资产是你的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三，保护资产有技术难度。&lt;/strong&gt;保护区块链资产是有一定的技术门槛的，普通的用户是很难做到，能安全的保护自己的区块链资产的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四。资产价值是基于技术的。&lt;/strong&gt;因此，一旦技术被人操控。操控者就可以任意偷取利益，甚至使得资产价值归零。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第五。各种中心的形成。&lt;/strong&gt;即便区块链网络上的资产是安全的，但是由于行业中的/交易所、托管钱包、矿池等企业的系统是集中化的，他们将会成为黑客攻击的目标，而且因为是中心化的，一旦攻击成功，影响面将会非常大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第六。空气币。&lt;/strong&gt;由于现在币圈浮躁，空气币频现，他们的目的，只是为了圈钱套现，所以说不可能会好好的做安全，这甚至会导致劣币驱逐良币，让其他做好安全的优质区块链项目，反而不受重视。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第七。空投项目信息泄漏。&lt;/strong&gt;空投项目用用户信息换币，但因为没做好安全，常常被撞库、脱库，这导致的信息泄露会进一步危害用户的其他资产。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结 &lt;/h2&gt;

&lt;p&gt;其实各种危害可以讲上很久了，但是因为安全不是免费的。能够正视这些危害，并且投入资金和精力去降低安全漏洞的意愿却依旧不高。时间有限，小冰也就不再详述了。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://36kr.com/p/5141823.html&quot;&gt;&lt;em&gt;https://36kr.com/p/5141823.html&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>区块链上的随机数</title>
   <link href="http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
   <updated>2018-09-18T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/区块链上的随机数</id>
   <content type="html">&lt;h2 id=&quot;随机数&quot;&gt;随机数&lt;/h2&gt;

&lt;p&gt;随机数的使用，由来已久，用在了生活中各个方面，比如说游戏，博弈等。产生随机数的方法有很多。自古以来我们就使用掷骰子、抛硬币等方法产生随机数。进入到计算机时代过后，我们使用计算机产生伪随机数。或者利用传感器获取来自物理世界的随机数。这类传统的随机数生成方法已经是有了充分的研究和讨论。&lt;/p&gt;

&lt;p&gt;但区块链上的随机数，和以往的都不太一样。&lt;/p&gt;

&lt;p&gt;随机数对于区块链技术来说非常的关键，其实从本质上讲，区块链作为分布式账本的一个核心，就是在于需要随机的选出区块的记账人，而这个随机性还必须可以证明，不能被操控，也不应该能够被预测。否则就会有恶意节点会利用这个特性，对区块链进行攻击。&lt;/p&gt;

&lt;h2 id=&quot;区块链上的随机数&quot;&gt;区块链上的随机数&lt;/h2&gt;

&lt;p&gt;下面就现行的两大区块链共识机制分别讨论。&lt;/p&gt;

&lt;p&gt;在pow工作量证明方案中。就是要所有节点竞争计算一道较难的数学题。只有当算力高的节点，才有较高的概率成为记账人。&lt;/p&gt;

&lt;p&gt;在pos权益证明方案中。只有拥有权益证明份额高的，才有较高的几率成为记账人。前几天提到过的algorand其实也是利用特制的随机数方法，来使得，在pos权益证明机制下。能让所有权益拥有者，更加平均的获得记账几率。使其更加随机，被操控的可能性更小。&lt;/p&gt;

&lt;p&gt;使用共识机制产生区块可以确保区块链的不可篡改性，但其代价较高，作为小范围使用的随机数，必然不会用这样的共识机制去明确随机数的公平性，但可以基于已经获得共识的区块链平台来做随机数发生器。&lt;/p&gt;

&lt;h2 id=&quot;区块链上的随机数生成器的难度&quot;&gt;区块链上的随机数生成器的难度 &lt;/h2&gt;

&lt;p&gt;区块链作为一个去中心化的平台。所有信息都是公开的，因此设计一个可用的随机数发生器，难度是更大的。这个随机数生成器，除了应该满足/无法预测/这个特性之外还应该有不可操控，难以串谋，可证公平这几个特点。我们都知道，区块链是一个分布式的账本。在每一个节点上都会重复同样的操作。如果让每一个节点都产生自己的随机数，那运行的结果将会完全不同。所以说，显然在区块链上的随机数生成器，将会与传统的随机数生成机制完全不同。&lt;/p&gt;

&lt;p&gt;如果区块链网络是通过获得物理传感器信息的方式产生随机数，将涉及到上链安全的问题。使得负责上链的节点具备操控随机数的能力。如果使用计算机生成伪随机数时，当只有一个人参与时，显而易见。这个人可以提前知道随机数是什么，无法保证公平。如果是多人合作时，这必然存在最后一个参与者。该参与者相比其他人拥有更大的优势，因为他可以提前知道这个生成的随机数。并可以根据情况改变提交的内容，或者选择不提交。使得最后一个参与者，能够操控随机数。另外，在多个合作者的情况，还有串谋的可能。&lt;/p&gt;

&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;

&lt;h3 id=&quot;预言机制&quot;&gt;预言机制&lt;/h3&gt;

&lt;p&gt;代表有Oraclize和Reality Keys方案。&lt;/p&gt;

&lt;p&gt;它是将一个受信第三方的数据源，搬运到链上，这个数据源是基于tls，就是而我们浏览网站是常看见的https。由于有服务器的签名在，所以这个搬运工本身是无法作假的，这也被称为tls公证机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点是&lt;/strong&gt;，获取随机数的速度快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点是&lt;/strong&gt;，仍旧无法防止，数据的提供方本身作假，或修改内容。&lt;/p&gt;

&lt;h3 id=&quot;区块数据作为种子&quot;&gt;区块数据作为种子&lt;/h3&gt;

&lt;p&gt;使用区块链上的区块数据作为产生随机数的种子信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点是&lt;/strong&gt;，所有数据都来自区块链。安全可证。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点是&lt;/strong&gt;。当修改随机数可获得的利益，比单个区块的奖励更多时，矿工有可能会被贿赂，而去试图构造有利于自己的区块，从而操控随机数。&lt;/p&gt;

&lt;h3 id=&quot;多人合作生成随机数&quot;&gt;多人合作生成随机数&lt;/h3&gt;

&lt;p&gt;使用智能合约的方式。多个参与者分别向这个智能合约发送自己挑选的任意数字。一段时间后，智能合约将收集到的这些数字，通过一些数学计算构造出一个最终数字。最终的这个数字将作为随机数返还给参与者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点是&lt;/strong&gt;。从多个不同的来源获得的种子数，来生成最后的随机数。随机性可得到保障。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点是&lt;/strong&gt;。若某一时段，没有足够多的参与者，将无法获得有效的随机数。而且。由于需要等待参与者的加入，获取该随机数的时间会比较缓慢。&lt;/p&gt;

&lt;h3 id=&quot;门限签名随机数&quot;&gt;门限签名随机数&lt;/h3&gt;

&lt;p&gt;所有成员有一个逻辑上的私钥，但每个成员只有这个私钥的一部分，完整的私钥不会存在于任何成员手中，因此没有成员能够直接计算出签名，签名的时候，每个成员都将使用自己拥有的那部分私钥对信息进行签名，然后收集到足够多的成员签名，就可以计算出完整的签名，但依旧无法倒推出完整的私钥。因此单个成员都无法作恶。最终计算出的签名可作为随机数使用。在签名过程中，没有个体能够提前预知签名结果，因此无法操纵随机数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点是&lt;/strong&gt;，安全性高，可以防止串谋。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点是&lt;/strong&gt;，生成随机数的成本较高，速度会比较慢，需要等待所有成员签名。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结 &lt;/h2&gt;

&lt;p&gt;由此可见，在区块链上的随机算法，也是非常复杂和非常重要的，因为他的使用范围广，而且他比以往的随机数算法都更加的安全和经得起审计，而一个不合格的随机算法会带来的不公平对于用户和应用来说，可能会是灾难性的。&lt;/p&gt;

&lt;p&gt;整体来说，区块链网络中的随机数算法，将会是未来发展的一个重要方向。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://yi-programmer.com/2018-03-08_randomness-in-blockchain.html&quot;&gt;&lt;em&gt;http://yi-programmer.com/2018-03-08_randomness-in-blockchain.html&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://randao.org/whitepaper/Randao_v0.85.pdf&quot;&gt;&lt;em&gt;https://randao.org/whitepaper/Randao_v0.85.pdf&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/elwingao/article/details/53763175&quot;&gt;&lt;em&gt;https://blog.csdn.net/elwingao/article/details/53763175&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>看白皮书时应该关注什么</title>
   <link href="http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/%E7%9C%8B%E7%99%BD%E7%9A%AE%E4%B9%A6%E6%97%B6%E5%BA%94%E8%AF%A5%E5%85%B3%E6%B3%A8%E4%BB%80%E4%B9%88/"/>
   <updated>2018-09-16T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/看白皮书时应该关注什么</id>
   <content type="html">&lt;p&gt;经常听到大家有这么一个疑问。我已经大概理解了区块链技术，但是去看别人的白皮书，还是一头雾水，甚至都不知道从哪里看起。&lt;/p&gt;

&lt;p&gt;所以今天就来讲一下。如何阅读白皮书？&lt;/p&gt;

&lt;p&gt;不过这里我要特别再提醒一下，冰河魔法师这里讲的全部是链圈的事情，也就是纯技术的。并不会对大家如何投资加密货币提出建议。看白皮书的方式也是以技术为导向，并非以看其代币价值是否会上涨为判定依据。&lt;/p&gt;

&lt;h2 id=&quot;区块链机制&quot;&gt;区块链机制&lt;/h2&gt;

&lt;p&gt;鉴于现在区块链项目，整个行业的同质化都比较严重，所以说通常情况下。大部分的区块链项目都是基于已有的开源区块链项目做的。如果白皮书里面并没有详细描述它所使用的区块链机制。那就只能根据它/所基于的区块链项目/去具体查看该项目的白皮书，或者说明文档。看到这些细节后。我们应该主要关注：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;区块交易结构&lt;/li&gt;
  &lt;li&gt;验证数据完整性的机制&lt;/li&gt;
  &lt;li&gt;智能合约的支持情况&lt;/li&gt;
  &lt;li&gt;共识机制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一点，区块交易的结构。通常情况下，无外乎是类似于比特币的复式记账结构，或者类似于以太坊的数据更新存储结构。或者使用基于DAG网络关联结构。在这里都不详细展开了。不清楚的同学可以参看我的其他课程，都对这些有详细描述。&lt;/p&gt;

&lt;p&gt;第二点，验证数据完整性的机制。现在通常使用的就是哈希树，也就是默克尔树。因此我们主要关注的是，他使用哈希树把哪些数据包含进去了，是否将所有我们认为不可篡改的数据都包含在内。&lt;/p&gt;

&lt;p&gt;第三点，智能合约。现在总的来说，大体分为两种智能合约执行方式。一种是原生代码执行，其优点是运行效率高、支持语言广泛，但安全性相对较低，且有跨平台不可靠的风险。另外一种智能合约执行方式，也是被用得最广泛的，是虚拟机模式。其优点就是安全。可靠。跨平台能力强。但是通常编程语言受限。只有该区块链支持的仅有的几种编程语言可以被使用。在语言的选用上，通常情况有两种方式。一是选用和平台开发语言一样的语言，尤其当/该区块链平台的开发语言是动态语言时，尤为突出。另外一种，是选用专用的区块链开发语言，比如现在应用最广泛的，以太坊的solidity语言。&lt;/p&gt;

&lt;p&gt;第四点，共识机制。需要认清楚这个区块链是使用的pow工作量证明还是pos权益证明。或者是选用了联盟链的pbft实用拜占庭容错算法或ba拜占庭协议。在这里也不详解了，因为每一个不同的共识方法都可以讲上一讲，不清楚的同学，请参看我的其他课程。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h2 id=&quot;代币机制&quot;&gt;代币机制&lt;/h2&gt;

&lt;p&gt;冰河魔法师多次提到，自己是链圈的。不涉及币圈，但是不得不说。作为价值互联网的区块链，没有代币或者通证。他是无法做到价值流转的。因此代币机制是一个试图作为价值互联网的区块链项目所必须的。在这里，主要需要关心的是，代币的总量和分配方案，以及代币的获取方法，甚至是未来的销毁方法。在业界，有这么一个笑话。几乎所有的知名区块链项目都通过ICO筹钱发币，但只有一个项目没有，那就是中本聪的比特币。&lt;/p&gt;

&lt;h2 id=&quot;落地项目&quot;&gt;落地项目&lt;/h2&gt;

&lt;p&gt;看完上面提到的这些之后，最后我们才需要看的是，这个区块链项目他要落地的是什么样的项目？这样的项目是否能够受到区块链技术的加成。是否可以真正的落地？他是否真的有痛点需要区块链来构造这么一个价值互联网。或者它只是使用区块链的防篡改性。以此为基础来论证解决方案的可行性和具体的产品功能特性。&lt;/p&gt;

&lt;h2 id=&quot;其他内容&quot;&gt;其他内容 &lt;/h2&gt;

&lt;p&gt;其实到这里，白皮书里面的主要内容应该就看完了，通常情况下，白皮书里面可能还会有一些其他内容。比如说对当前各种区块链的一种创新。创新通常都是有较高的代价的。它也不可能在某一点创新上就能做到像中本聪创建的区块链这么一个巨大的创新，这样的级别。因此这些创新部分，对于绝大多数白皮书来说，反倒不用太在意。除非这一个区块链项目就是以创新著称，比如说当你在阅读以太坊的白皮书，或者前两天我推荐过的algorand的白皮书时/才需要考虑的。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结 &lt;/h2&gt;

&lt;p&gt;听到这里，白皮书的阅读方法就已经讲完了。如果身处币圈，你可能还会想知道通过这个白皮书，如何能够知道这个区块链项目是不是空气币？不过不得不失望的说。除非你能看到这个项目在切实的盈利。否则谁也无法证明它不是空气币。至于币圈里常说的，要看团队成员、市场前景、项目发展和路线图、代币发行平台、落地解决方案之类的，以及是否有大佬背书等。 作为链圈的冰河魔法师就不再详细描述了。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>去中心化交易所</title>
   <link href="http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80/"/>
   <updated>2018-09-15T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/去中心化交易所</id>
   <content type="html">&lt;h2 id=&quot;中心化交易所&quot;&gt;中心化交易所&lt;/h2&gt;

&lt;p&gt;这里先对去中心化交易所下个定义，加密货币交易所是指，提供加密货币之间，或加密货币与法币间交易服务的平台。根据用户是否对加密货币拥有绝对的控制权来区分中心化交易所和去中心化交易所。事实上，现在大多数的交易所都是中心化交易所，而大多数的所谓的去中心化交易所，也并非完全的去中心化。不同的去中心化方式，会有不同的去中心化程度。&lt;/p&gt;

&lt;p&gt;中心化交易所很容易受到黑客的青睐和攻击。每次受到攻击后，其损失都会比较严重，比如说，在2017年被盗的资金总价值，达到了5亿美元左右。如果把2017年以前的所有黑客攻击合在一起来算的话，损失的加密货币总价值，或许已经超过了125亿美元。&lt;/p&gt;

&lt;p&gt;当交易平台是中心化的时候，通常是通过资产控制，来使得交易平台正常的运行，这将类似于银行/这样的值得信任的机构。当使用中心化交易平台时，交易平台会实际拥有你自己的资金，直到你想要提现为止。这个过程中，平台通常将一部分的客户的资金存放在热钱包备用，而另外一部分则存放在冷钱包中。&lt;/p&gt;

&lt;h2 id=&quot;去中心化交易所&quot;&gt;去中心化交易所 &lt;/h2&gt;

&lt;p&gt;关于去中心化的交易所，网上有一种说法是，技术已经发展了三代，但我觉得其实主要分成两种不同的类型，&lt;/p&gt;

&lt;h3 id=&quot;代理型去中心化交易所&quot;&gt;代理型去中心化交易所&lt;/h3&gt;

&lt;p&gt;我们现在说第一种。
这种去中心化的交易所首先有一个具有代币功能的区块链网络，然后任何个人或交易所都可以成为这个区块链网络的代理人，代理人需要负责的是所有外部资产的存取，也就是法币或者其他代币资产的存入和取出。在这里，任何一个不在这个区块链网络上的资产，都可以在这里被定义为外部资产。&lt;/p&gt;

&lt;p&gt;用户首先需要向代理人充值，也就是将这些外部资产存入到代理人指定的地方。然后代理人将存在于这个区块链网络的一种代币发放给用户。&lt;/p&gt;

&lt;p&gt;如果仅就这一个步骤来说，它和中心化交易所其实是一样的。也就是说，如果用户在充值这个步骤当中，这个代理人消失了，那么用户的资产可能也就被盗了。&lt;/p&gt;

&lt;p&gt;所以为了更好的确保用户的资金安全，通常这些去中心化交易所会做一些限制。首先这个代理人要成为正式的代理人，它需要提供在这个区块链上的代币作为保证金。&lt;/p&gt;

&lt;p&gt;一旦代理人无法兑付，向代理人转入外部资产的用户就可以得到系统的清算补偿。补偿的来源就是保证金。这个机制是完全去中心化的。因此就对代理人的信任需求下降了。&lt;/p&gt;

&lt;h3 id=&quot;完全去中心化交易所&quot;&gt;完全去中心化交易所 &lt;/h3&gt;

&lt;p&gt;另外一种去中心化的交易所，是完全的去中心化的，他不需要有任何需要信任的代理人存在。其使用的智能合约，且所有代码都是公开的，可以查看，并且是经过大众审核的。&lt;/p&gt;

&lt;p&gt;我们都知道代码是不会骗人的，运行结果是非常确定的。因此这个过程当中并不需要保证金来保证资产安全。但是它有个限制，就是只能做加密货币、代币、通证等之间的交换。&lt;/p&gt;

&lt;p&gt;当然，这里面有两种情况，一种情况是，同一个区块链网络上，加密货币、代币、通证之间的交换。比如说，以太币，与在以太坊上的代币、通证之间的交换。&lt;/p&gt;

&lt;p&gt;而另外一种，是能够实现跨链的加密货币交换。但因为考虑到，每个区块链有自己的特性，如何跨链以及跨链后如何保证交换的原子性，即/交易能够同时在两条链上都确认完成的交换技术。也是当前的热门研究方向。&lt;/p&gt;

&lt;h2 id=&quot;交易模式&quot;&gt;交易模式&lt;/h2&gt;

&lt;p&gt;去中心化的交易所。其交易模式。其实也无外乎是，点对点撮合交易。或者中介储备交易。&lt;/p&gt;

&lt;p&gt;点对点撮合交易最简单，也是相对来说去中心化程度最高，对用户来说也是最安全的。就是用户和另外一个需要交易的用户直接进行加密货币或代币、通证等的直接兑换。&lt;/p&gt;

&lt;p&gt;而中介储备交易，则是由中介作为一个信任中心，临时的存储用户的一些加密货币。首先中介可能会存有一定量的储备资金。当用户发起交易时，可能会临时的使用储备资金，然后到一定时间后统一进行结算。这种方式会牺牲一定的去中心化，但是，但对于/有小额即时支付需求/的实际应用场景来说。会有更大的优势和发展潜力。&lt;/p&gt;

&lt;h2 id=&quot;优势&quot;&gt;优势 &lt;/h2&gt;

&lt;p&gt;去中心化的交易所，有个比较好的地方在于。在这样的一个去中心化的系统中，你一直拥有自己的私钥，并不需要向任何人透露，因此，你的资产始终是掌握在自己手中的。不用担心黑客攻击中心化平台后，导致资产丢失的问题。&lt;/p&gt;

&lt;p&gt;在使用上讲，去中心化的交易所，使用体验是大不如中心化交易所的，但是，这个能够让用户完全掌控自己的账户资金。这一点和区块链的去中心化思想是吻合的。所以相信它能够和区块链技术一同发展。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Algorand——随机权益证明共识</title>
   <link href="http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/Algorand%E9%9A%8F%E6%9C%BA%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E%E5%85%B1%E8%AF%86/"/>
   <updated>2018-09-14T00:00:00+08:00</updated>
   <id>http://icerdesign.com/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%94%E5%88%86%E9%92%9F/Algorand随机权益证明共识</id>
   <content type="html">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;今天讲一下algorand。这是我最近几天才新接触到的一个区块链底层技术。其主要贡献在共识算法上。其核心思想比较有新意，在我看来，其思想可能会在区块链的共识算法中，留下重要的一笔。&lt;/p&gt;

&lt;p&gt;先简单讲一下背景，algorand的背景相当的雄厚，是MIT机械工程与计算机科学系的Silvio
Micali教授为主要作者提出的区块链协议。他的研究领域包括密码学，零知识，伪随机数生成，安全协议和机制设计。1993年获得哥德尔奖，2004年获得了密码学领域的RSA奖，2012年获得图灵奖。这都是计算机领域重量级的大奖，而且获奖方向都是密码学领域。&lt;/p&gt;

&lt;p&gt;algorand是由算法的algorithm，和随机的random两个词合成的。顾名思义，就是基于随机算法的区块链协议。因此他提出了其设计目标是，能耗低。民主化。出现分叉的概率低。可扩展性好。&lt;/p&gt;

&lt;h2 id=&quot;基本机制&quot;&gt;基本机制&lt;/h2&gt;

&lt;p&gt;algorand中的很多设计与传统的比特币或以太坊的设计比较类似。&lt;/p&gt;

&lt;p&gt;就区块链网络来说，任意节点可以随时加入到网络中来，不需要申请，而且对节点数量也没有任何限制。&lt;/p&gt;

&lt;p&gt;就交易设计来说，使用电子签名机制，来锁定一定数量的货币。同样需要使用电子签名，从一个公钥转移一定数量的货币到另外一个公钥，并使用对应的私钥进行加密锁定。&lt;/p&gt;

&lt;p&gt;就区块设计来说。依旧是将上一个区块的哈希值指针放入当前区块，然后形成当前区块的哈希值，以确保任意前项区块的信息被篡改后，其后续区块会变得无效。&lt;/p&gt;

&lt;h2 id=&quot;创新做法&quot;&gt;创新做法&lt;/h2&gt;

&lt;p&gt;其不同点有，要求系统中拥有三分之二的权益的节点是诚实的，诚实被定义为，其行为遵守有关指引。并能完美的发送和接收消息。从这一点要求上就可以猜想出，其使用了拜占庭共识协议。&lt;/p&gt;

&lt;p&gt;另外一个显著区别在于，其并没有引入激励机制，甚至可以认为没有原生货币，仅有权益证明。&lt;/p&gt;

&lt;p&gt;整个algorand的机制中，最大的创新点就在于共识机制。共识机制的基础算法，非常类似于拜占庭协议。&lt;/p&gt;

&lt;p&gt;但其最突出的区别，也是它名字的来源。就是使用随机算法来选择下一批验证者。因此和传统的各种算法相比，最大的区别在于，所有的验证者都是可替换的。&lt;/p&gt;

&lt;h2 id=&quot;具体做法&quot;&gt;具体做法&lt;/h2&gt;

&lt;p&gt;每一轮中会创建一个种子参数，而且这个种子参数，是不可能被人预测，当然也就不可能被操纵了。&lt;/p&gt;

&lt;p&gt;在这一轮中，它会基于当前的种子参数构建，并公布一个随机算法。这种算法这也被称之为可验证的随机函数，该随机算法中的一个关键参数是用户的私钥，而这个私钥和各个区块链网络一样，都只有用户本人才知道。&lt;/p&gt;

&lt;p&gt;接下来每个用户使用自己的私钥运行系统公布的随机算法，得到自己的凭证。&lt;/p&gt;

&lt;p&gt;满足一定条件的用户，就是这一轮的验证者，而在这一个步骤当中，一个特殊的凭证获得者就是领导者。&lt;/p&gt;

&lt;p&gt;这个随机算法筛选验证者或者领导者的概率，是按照/用户所持有的网络资产权益/决定的。&lt;/p&gt;

&lt;p&gt;接下来，所有的验证者加领导者，共同运行拜占庭协议，来创建新的区块。&lt;/p&gt;

&lt;h2 id=&quot;特点&quot;&gt;特点&lt;/h2&gt;

&lt;p&gt;但他是如何做到，低能耗，民主化，出现分叉可能性小和可扩展性强的呢？&lt;/p&gt;

&lt;p&gt;该算法其本质是pos权益证明机制。因此，相比pow工作量证明，可以做到更低的能耗。&lt;/p&gt;

&lt;p&gt;该算法设计为公链，因此所有节点可以随时加入退出，做到了民主化。&lt;/p&gt;

&lt;p&gt;该算法基础共识方法为拜占庭算法，故出现分叉的几率小。&lt;/p&gt;

&lt;p&gt;值得特别提出的，这里所谓的发叉，跟我们一般说的，在区块链升级或改变时做的软分叉硬分叉，并不是同一个概念。无论区块链如何设计，他都不可能防止的了/被人修改共识协议后，进行的硬分叉。其硬分叉后可能形成的就是一个新的货币，对原货币并没有直接影响。因此通常不作讨论。&lt;/p&gt;

&lt;p&gt;最后其可拓展性好的特点，主要体现在实现低能耗后，提高交易速度的可能性比较高。&lt;/p&gt;

&lt;h2 id=&quot;如何防止攻击&quot;&gt;如何防止攻击？ &lt;/h2&gt;

&lt;p&gt;其实光听完这些，你可能会问，algorand如何防止攻击呢？&lt;/p&gt;

&lt;p&gt;我们可以来做一下，一个攻击的演示。&lt;/p&gt;

&lt;p&gt;由于每一次的验证者和领导者都是由随机算法通过种子参数计算出来的。而这个种子参数又是不可预测的，也不可被操纵的。因此没有人能够预测出下一轮的验证者和领导者是哪一些节点。&lt;/p&gt;

&lt;p&gt;在验证者和领导者在发出共识消息的时候，在这一瞬间。作恶者可能会知道这些信息以及这一轮哪些节点是验证者，然而因为这些信息是不可能撤回的，作恶者并没有机会去，篡改这些信息，或者让贿赂他们，使其撤回自己的信息。&lt;/p&gt;

&lt;p&gt;而进入到下一轮验证后，又会有新的一组验证者和领导者担任。&lt;/p&gt;

&lt;p&gt;因此想要攻击这个网络，必须是作恶的节点要足够多。这个比例在原论文当中并没有提出。我通过粗略的计算得出，当作恶者拥有整个网络30%的权益的时候。他作恶的成功率大概在4%左右。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结 &lt;/h2&gt;

&lt;p&gt;这是一个新兴的方法。而且作者本人就是常年研究密码学和随机数的，因此我们有理由相信其提出的随机数算法，是经得起验证的。在未来，这样的共识方法，很有可能会成为一个新的发展方向。&lt;/p&gt;

</content>
 </entry>
 
 
</feed>
